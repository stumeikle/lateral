package ${cachePackage};

//DO NOT MODIFY, this class was generated by xxx

import com.hazelcast.core.MapStoreFactory;
import ${implPackage}.*;
import com.hazelcast.core.MapLoader;
import transgenic.lauterbrunnen.lateral.di.ApplicationDI;
import transgenic.lauterbrunnen.lateral.cache.hazelcast.HCMapStoreFactory;
import transgenic.lauterbrunnen.lateral.di.DefaultImpl;
import transgenic.lauterbrunnen.lateral.persist.hazelcast.DummyMapStore;
import transgenic.lauterbrunnen.lateral.persist.hazelcast.HCMapStoreRT;
import transgenic.lauterbrunnen.lateral.persist.hazelcast.HCMapStoreRWT;
import transgenic.lauterbrunnen.lateral.persist.hazelcast.HCMapStoreWT;
import static transgenic.lauterbrunnen.lateral.di.ApplicationDI.inject;
import java.util.Properties;

@DefaultImpl
public class HCMapStoreFactoryImpl implements HCMapStoreFactory{

    //should be configurable. write-through, read-through
    private MapStoreFactory[] factories = {this::noReadNoWrite, this::readNoWrite, this::writeNoRead,
                                           this::readAndWrite};
    private int index = 0;

    @Override
    public MapLoader<Object, Object> newMapStore(String s, Properties properties) {
        return factories[index].newMapStore(s, properties);
    }

    @Override
    public void setWriteThrough(boolean writeThrough) {
        if (writeThrough) index+=2;
    }

    @Override
    public void setReadThrough(boolean readThrough) {
        if (readThrough) index++;
    }

    public MapLoader<Object, Object> noReadNoWrite(String s, Properties properties) {
        return new DummyMapStore();
    }

    //Expectation is ...
    // readNoWrite means write-behind, remote dbdumper in use
    // and
    // readAndWrite means no remote dbdumper, both operations go to a direct store
    //

    public MapLoader<Object, Object> readNoWrite(String s, Properties properties) {

#foreach( $name in $allNames )
        if ("${name}".equals(s)) {
            ${name}Retriever retriever = inject(${name}Retriever.class);
            if (retriever==null) retriever = new ${name}RetrieverImplRemote();
            return new HCMapStoreRT(retriever);
        }
#end
		// need to add admin dummy map store in here
        if ("AdminCommandQueue".equals(s)){ return new DummyMapStore(); }

        return null;
    }

    public MapLoader<Object, Object> writeNoRead(String s, Properties properties) {
#foreach( $name in $allNames )
        if ("${name}".equals(s)) {
            ${name}Persister persister = inject(${name}Persister.class);
            if (persister==null) persister = new ${name}PersisterImplDirect();
            return new HCMapStoreWT(persister);
        }
#end
		// need to add admin dummy map store in here
        if ("AdminCommandQueue".equals(s)){ return new DummyMapStore(); }

        return null;
    }

    public MapLoader<Object, Object> readAndWrite(String s, Properties properties) {
#foreach( $name in $allNames )
        if ("${name}".equals(s)) {
            ${name}Persister persister = inject(${name}Persister.class);
            if (persister==null) persister = new ${name}PersisterImplDirect();
            ${name}Retriever retriever = inject(${name}Retriever.class);
            if (retriever==null) retriever = new ${name}RetrieverImplDirect();
            return new HCMapStoreRWT(retriever,persister);
        }
#end
		// need to add admin dummy map store in here
        if ("AdminCommandQueue".equals(s)){ return new DummyMapStore(); }

        return null;
    }

}
