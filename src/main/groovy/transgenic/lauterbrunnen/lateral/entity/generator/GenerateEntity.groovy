package transgenic.lauterbrunnen.lateral.entity.generator

import java.lang.reflect.Field
import java.lang.reflect.Modifier
import java.lang.reflect.ParameterizedType
import java.lang.reflect.Type
import java.util.function.Consumer

/**
 * Created by stumeikle on 06/06/16.
 */
class GenerateEntity {

    private String implPackage;
    private String jpaEntityPackage;
    private Properties properties;
    private String idFieldName;
    private String basePath;
    private Map<String, String>  idFields = new HashMap<>();
    private Map<String, String> idFieldNames = new HashMap<>();

    public void setImplPackage( String implPackage ) {
        this.implPackage = implPackage;
    }
    public void setJpaEntityPackage( String jpaEntityPackage ) {
        this.jpaEntityPackage = jpaEntityPackage;
    }
    public void setProperties(Properties properties) {
        this.properties = properties;
    }
    public void setIdFieldName(String idFieldName) {
        this.idFieldName = idFieldName;
    }
    public void setIdFields(Map<String, String> idFields) {
        this.idFields = idFields;
    }
    public void setIdFieldNames(Map<String, String> idFields) {
        this.idFieldNames = idFields;
    }
    public void setBasePath(String basePath) {
        this.basePath=basePath;
    }

    public void generate(Class proto, Class impl) {

        //we're going to write the entity and the transformer here together
        //as we have all the info for the transformer here in one place too

        def fn = basePath + "/"+  jpaEntityPackage.replaceAll("\\.","/") + "/" + proto.getSimpleName() + "Entity.java";
        println "Writing " + fn;
        def output = new File(fn);

        def transformerfn = basePath + "/"+jpaEntityPackage.replaceAll("\\.","/") + "/" + proto.getSimpleName() + "EntityTransformer.java";
        println "Writing " + transformerfn;
        def transformer = new File(transformerfn);

        writeTransformerHeader(transformer, proto);

        output << "package " + jpaEntityPackage + ";" << System.lineSeparator()
        output << "" << System.lineSeparator();
        output << "//DO NOT MODIFY, this class was generated by xxx " << System.lineSeparator();
        output << ""<< System.lineSeparator();

        output << "import javax.persistence.*;" << System.lineSeparator();

        output << "" << System.lineSeparator();
        output << "@Entity" << System.lineSeparator();
        output << "@Table(name=\"" << getColumnName(proto.getSimpleName()) << "\")" <<System.lineSeparator()
        output << "public class " << proto.getSimpleName() << "Entity {" << System.lineSeparator();
        output << "" << System.lineSeparator();

        //copy all the fields from the impl
        //skip the transient fields
        //swap any proto classes for the corresponding entity
        //swap any types defined in the properties file

        for(Field field : impl.getDeclaredFields()) {
            if (field.getModifiers() & Modifier.TRANSIENT) continue;

            String type = swapType( field.getGenericType() );
            output << "    private " << type << " " << field.getName() << ";" << System.lineSeparator()
        }

        //Getters and setters
        for (Field field: impl.getDeclaredFields()) {
            if (field.getModifiers() & Modifier.TRANSIENT) continue;

            String firstUpperFN = field.getName().substring(0, 1).toUpperCase() + field.getName().substring(1);
            String type = swapType(field.getGenericType());

            boolean useJoin = false;
            if (field.getType().getTypeName().contains(implPackage)) useJoin = true;

            output << "" << System.lineSeparator()
            if (field.getName().equals(idFieldName)) {
                output << "    @Id" << System.lineSeparator()
            }

            String columnName = getColumnName(field.getName());
            String columnExtra = properties.get("entity.column.definition." + type);

            String col = "Column"
            if (columnExtra == null) {
                output << "    @" << col << "(name=\"" << columnName << "\")" << System.lineSeparator()
            } else {
                output << "    @" << col << "(name=\"" << columnName << "\" , columnDefinition=\"" + columnExtra + "\")" << System.lineSeparator()
            }

            //if its a collection we need specific annotations
            if (field.getType().getInterfaces()!=null) {
                for (Class iface : field.getType().getInterfaces()) {
                    if (iface.getName().equals(Collection.class.getName())) {
                        output << "    @ElementCollection(fetch=FetchType.LAZY)"<< System.lineSeparator()

                        String nameInCaps = getColumnName(proto.getSimpleName());
                        String idInCaps = getColumnName(idFieldName);
                        String fieldInCaps = getColumnName(field.getName());

                        output << "    @CollectionTable(name=\"" << nameInCaps << "_X_" << fieldInCaps << "\", joinColumns={@JoinColumn(name=\"" << nameInCaps << "_" <<
                                idInCaps << "\")})" << System.lineSeparator()
                    }
                }
            }

            //and if its a map almost the same
            boolean isMap =false;
            if (Map.class.getName().equals(field.getType().getTypeName())) isMap=true;
            if (!isMap && field.getType().getInterfaces()!=null) {
                for (Class iface : field.getType().getInterfaces()) {
                    if (iface.getName().equals(Map.class.getName())) {
                            isMap=true;
                        break;
                    }
                }
            }

            if (isMap) {
                output << "    @ElementCollection(fetch=FetchType.LAZY)"<< System.lineSeparator()

                String nameInCaps = getColumnName(proto.getSimpleName());
                String idInCaps = getColumnName(idFieldName);
                String fieldInCaps = getColumnName(field.getName());

                output << "    @MapKeyColumn(name=\"MAP_KEY\")" << System.lineSeparator()
                output << "    @CollectionTable(name=\"" << nameInCaps << "_X_" << fieldInCaps << "\", joinColumns={@JoinColumn(name=\"" << nameInCaps << "_" <<
                        idInCaps << "\")})" << System.lineSeparator()
            }


            output << "    public " + type + " get" + firstUpperFN + "() {" << System.lineSeparator()
            output << "        return this." + field.getName() + ";" << System.lineSeparator()
            output << "    }" << System.lineSeparator()

            output << System.lineSeparator();
            output << "    public void set" + firstUpperFN + "( " + type + " " + field.getName() + ") {" << System.lineSeparator()
            output << "        this." + field.getName() + " = " + field.getName() + ";" << System.lineSeparator()
            output << "    }" << System.lineSeparator()

            //generate the setter to the entity from the impl for this field ----------------------------------------
            createSetLogic( transformer, field, firstUpperFN );

            //-------------------------------------------------------------------------------------------------------
        }

        output << "" << System.lineSeparator()
        output << "}" << System.lineSeparator()

        writeTransformerTail(transformer);
    }

    private void iterateGenerics(Type type, Consumer<Type> classConsumer) {
        if (type instanceof ParameterizedType) {
            ParameterizedType p = (ParameterizedType)type;
            classConsumer.accept(p);
            for(Type t : p.getActualTypeArguments()) {
                classConsumer.accept(t);
                if (t instanceof ParameterizedType)
                { iterateGenerics((ParameterizedType)t, classConsumer); }
            }
        }
    }

    public String swapType(Type type) {
        if (type instanceof ParameterizedType) {
            ParameterizedType p = (ParameterizedType) type;
            String retval = swapTypeName(p.getRawType().getTypeName());
            retval += "<";
            //then do the parameters
            boolean first = true;
            for (Type t : p.getActualTypeArguments()) {
                if (!first) retval = retval + ",";
                retval = retval + swapType(t);
                first = false;
            }
            retval += ">";
            return retval;
        }
        String retval = swapTypeName(type.getTypeName());
        return retval;
    }

    public String swapTypeName(String fieldName) {

        String newFieldName = fieldName;
        if (newFieldName.contains(implPackage)) {
            //in this case we need to swap it for the repository id field type
            //as it's a reference
            String urgName = idFields.get(fieldName);
            if (urgName!=null) {
                newFieldName = urgName;
            }
        }

        String propswap = properties.get("entity.swap.type." + newFieldName);
        if (propswap!=null) newFieldName = propswap;


        if ("int".equals(newFieldName)) newFieldName = "Integer";
        if ("long".equals(newFieldName)) newFieldName = "Long";
        if ("float".equals(newFieldName)) newFieldName = "Float";
        if ("double".equals(newFieldName)) newFieldName = "Double";
        if ("boolean".equals(newFieldName)) newFieldName= "Boolean"; //perhaps

        return newFieldName;
    }

    public String getColumnName(String fieldName) {
        fieldName = fieldName.replaceAll(/([a-z])([A-Z])/) { all, first, second ->
            first + "_" + second
        }

        return fieldName.toUpperCase();
    }

    private void createSetLogic(def transformer, Field field, String firstUpperFN) {
        Type type = field.getGenericType();

        //need to transform the fieldname
        String fufn = "get" + firstUpperFN;
        if (field.getType().getTypeName().equalsIgnoreCase("Boolean"))
        {
            fufn = field.getName();
        }

        String fieldName = "impl." + fufn + "()";

        //prefix need to be controlled by annotations TODO
        transformer << "        ";
        if (!field.getType().isPrimitive())
            transformer << "if (impl." << fufn << "()!=null) "
        transformer << "entity.set" + firstUpperFN + "("

        recurseSetLogic(transformer, type, fieldName);

        transformer << ");" << System.lineSeparator();
    }

    private void recurseSetLogic(def transformer, Type type, String fieldName) {

        String typeName= type.getTypeName();
        if (type instanceof ParameterizedType) {
            typeName = ((ParameterizedType)type).getRawType().getTypeName();
        }

        if (typeName.contains(implPackage)) {
            String ref = type.getTypeName() + "Reference";
            transformer << "((" + ref + ")" + fieldName + ").getRepositoryId()";

            //sometimes the repository id is eg unique id but we need to convert it to eg byte[]
            String reptype =idFields.get(type.getTypeName());
            String converter = properties.get("entity.type.converter." + reptype);
            if (converter!=null) {
                transformer << converter;
            }

        } else {

            if (type instanceof ParameterizedType) {
                ParameterizedType pt = (ParameterizedType) type;
                String rawname = pt.getRawType().getTypeName();

                handleList(transformer, rawname, fieldName, pt);
                handleMap( transformer, rawname, fieldName, pt);

            }
            else {
                transformer << fieldName;
                String converter = properties.get("entity.type.converter." + type.getTypeName());
                if (converter != null) {
                    transformer << converter;
                }
            }
        }
    }

    private void handleList( def transformer, String rawName, String fieldName, ParameterizedType parameterizedType) {
        try {

            Class c = Class.forName(rawName);
            boolean list = false;
            if (List.class.getName().equals(c.getName())) list = true;
            for(Class iface: c.getInterfaces()) {
                if (List.class.getName().equals(iface.getName())) {
                    list = true;
                    break;
                }
            }

            if (list) {
                //preamble
                transformer << fieldName << " == null ? null : "+ fieldName + ".stream().map( item -> " << System.lineSeparator();
                transformer << "            ";

                //then recurse into the type
                for (Type t : parameterizedType.getActualTypeArguments()) {
                    recurseSetLogic(transformer,t, "item");
                }

                //then postamble
                transformer << System.lineSeparator() << "        ).collect(Collectors.toList())"

            }

        } catch(Exception e) {
            e.printStackTrace();
        }
    }

    private void handleMap( def transformer, String rawName, String fieldName, ParameterizedType parameterizedType) {
        try {
            Class c = Class.forName(rawName);
            boolean map = false;
            if (Map.class.getName().equals(c.getName())) map = true;
            for(Class iface: c.getInterfaces()) {
                if (Map.class.getName().equals(iface.getName())) {
                    map = true;
                    break;
                }
            }

            if (map) {
                //preamble
                transformer << fieldName + " ==null ? null : " << fieldName + ".entrySet().stream().collect(Collectors.toMap( " << System.lineSeparator()
                transformer << "            e -> "

                //then recurse into the type
                Type keytype = parameterizedType.getActualTypeArguments()[0];
                recurseSetLogic(transformer, keytype, "e.getKey()");
                transformer << "," << System.lineSeparator()
                transformer << "            e-> ";
                Type valuetype = parameterizedType.getActualTypeArguments()[1];
                recurseSetLogic(transformer, valuetype,"e.getValue()");

                //then postamble
                transformer << "))"

            }

        } catch(Exception e) {}
    }

    private void writeTransformerHeader(def transformer, Class proto) {

        transformer << "package " + jpaEntityPackage + ";" << System.lineSeparator()
        transformer << "" << System.lineSeparator();
        transformer << "//DO NOT MODIFY, this class was generated by xxx " << System.lineSeparator();
        transformer << ""<< System.lineSeparator();
        transformer << "import java.util.stream.Collectors;" << System.lineSeparator()
        transformer << ""<< System.lineSeparator();
        transformer << "public class " << proto.getSimpleName() << "EntityTransformer {" << System.lineSeparator();
        transformer << "" << System.lineSeparator();
        transformer << "    public static void transform(" << proto.getSimpleName() << "Entity entity, " <<
                implPackage << "." << proto.getSimpleName() << "Impl impl) {" << System.lineSeparator();
    }

    private void writeTransformerTail(def transformer) {
        transformer << "    }" << System.lineSeparator()
        transformer << "}" << System.lineSeparator()
    }
}
