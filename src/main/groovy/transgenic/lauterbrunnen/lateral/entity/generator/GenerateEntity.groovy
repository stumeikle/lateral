package transgenic.lauterbrunnen.lateral.entity.generator

import transgenic.lauterbrunnen.lateral.domain.generator.GenerateConverterName

import java.lang.reflect.Field
import java.lang.reflect.Modifier
import java.lang.reflect.ParameterizedType
import java.lang.reflect.Type
import java.util.function.Consumer

/**
 * Created by stumeikle on 06/06/16.
 */
class GenerateEntity {

    private String implPackage;
    private String jpaEntityPackage;
    private Properties properties;
    private String idFieldName;
    private String basePath;
    private Map<String, String>  idFields = new HashMap<>();
    private Map<String, String> idFieldNames = new HashMap<>();

    public void setImplPackage( String implPackage ) {
        this.implPackage = implPackage;
    }
    public void setJpaEntityPackage( String jpaEntityPackage ) {
        this.jpaEntityPackage = jpaEntityPackage;
    }
    public void setProperties(Properties properties) {
        this.properties = properties;
    }
    public void setIdFieldName(String idFieldName) {
        this.idFieldName = idFieldName;
    }
    public void setIdFields(Map<String, String> idFields) {
        this.idFields = idFields;
    }
    public void setIdFieldNames(Map<String, String> idFields) {
        this.idFieldNames = idFields;
    }
    public void setBasePath(String basePath) {
        this.basePath=basePath;
    }

    private Set<GenerateConverterName>  converterNames;

    public void generate(Class proto, Class impl) {

        //we're going to write the entity and the transformer here together
        //as we have all the info for the transformer here in one place too

        def fn = basePath + "/"+  jpaEntityPackage.replaceAll("\\.","/") + "/" + proto.getSimpleName() + "Entity.java";
        println "Writing " + fn;
        def output = new File(fn);

        def transformerfn = basePath + "/"+jpaEntityPackage.replaceAll("\\.","/") + "/" + proto.getSimpleName() + "EntityTransformer.java";
        println "Writing " + transformerfn;
        def transformer = new File(transformerfn);
        def transformTo = new StringBuilder();
        def transformFrom = new StringBuilder();

        converterNames = new HashSet<>();

        writeTransformerHeader(transformer, proto);
        writeTransformToDeclaration(transformTo, proto);
        writeTransformFromDeclaration(transformFrom, proto);

        output << "package " + jpaEntityPackage + ";" << System.lineSeparator()
        output << "" << System.lineSeparator();
        output << "//DO NOT MODIFY, this class was generated by xxx " << System.lineSeparator();
        output << ""<< System.lineSeparator();

        output << "import javax.persistence.*;" << System.lineSeparator();

        output << "" << System.lineSeparator();
        output << "@Entity" << System.lineSeparator();
        output << "@Table(name=\"" << getColumnName(proto.getSimpleName()) << "\")" <<System.lineSeparator()
        output << "public class " << proto.getSimpleName() << "Entity {" << System.lineSeparator();
        output << "" << System.lineSeparator();

        //copy all the fields from the impl
        //skip the transient fields
        //swap any proto classes for the corresponding entity
        //swap any types defined in the properties file

        for(Field field : impl.getDeclaredFields()) {
            if (field.getModifiers() & Modifier.TRANSIENT) continue;

            String type = swapType( field.getGenericType() );
            output << "    private " << type << " " << field.getName() << ";" << System.lineSeparator()
        }

        //Getters and setters
        for (Field field: impl.getDeclaredFields()) {
            if (field.getModifiers() & Modifier.TRANSIENT) continue;

            String firstUpperFN = field.getName().substring(0, 1).toUpperCase() + field.getName().substring(1);
            String type = swapType(field.getGenericType());

            boolean useJoin = false;
            if (field.getType().getTypeName().contains(implPackage)) useJoin = true;

            output << "" << System.lineSeparator()
            if (field.getName().equals(idFieldName)) {
                output << "    @Id" << System.lineSeparator()
            }

            String columnName = getColumnName(field.getName());

            //if the column is a collection we may need to use the column extra from the contained type here
            //(1) is it a list
            //    yes -> get the contained type
            //           if db text is provided use that in the column definition
            //           if the contained type is also a collection. stop, we can't do that yet
            //(2) is it a map
            //    yes -> do the same with the map key
            //

            if (!addListAnnotation(field, columnName, output, proto) && !addMapAnnotation(field,columnName,output, proto)) {
                //do the 'normal' case
                String columnExtra = properties.get("entity.column.definition." + type);
                String col = "Column"
                if (columnExtra == null) {
                    output << "    @" << col << "(name=\"" << columnName << "\")" << System.lineSeparator()
                } else {
                    output << "    @" << col << "(name=\"" << columnName << "\" , columnDefinition=\"" + columnExtra + "\")" << System.lineSeparator()
                }
            }

            /*
            //if its a collection we need specific annotations
            if (field.getType().getInterfaces()!=null) {
                for (Class iface : field.getType().getInterfaces()) {
                    if (iface.getName().equals(Collection.class.getName())) {
                        output << "    @ElementCollection(fetch=FetchType.LAZY)"<< System.lineSeparator()

                        String nameInCaps = getColumnName(proto.getSimpleName());
                        String idInCaps = getColumnName(idFieldName);
                        String fieldInCaps = getColumnName(field.getName());

                        output << "    @CollectionTable(name=\"" << nameInCaps << "_X_" << fieldInCaps << "\", joinColumns={@JoinColumn(name=\"" << nameInCaps << "_" <<
                                idInCaps << "\")})" << System.lineSeparator()
                    }
                }
            }*/
/*
            //and if its a map almost the same
            boolean isMap =false;
            if (Map.class.getName().equals(field.getType().getTypeName())) isMap=true;
            if (!isMap && field.getType().getInterfaces()!=null) {
                for (Class iface : field.getType().getInterfaces()) {
                    if (iface.getName().equals(Map.class.getName())) {
                            isMap=true;
                        break;
                    }
                }
            }

            if (isMap) {
                output << "    @ElementCollection(fetch=FetchType.LAZY)"<< System.lineSeparator()

                String nameInCaps = getColumnName(proto.getSimpleName());
                String idInCaps = getColumnName(idFieldName);
                String fieldInCaps = getColumnName(field.getName());

                output << "    @MapKeyColumn(name=\"MAP_KEY\")" << System.lineSeparator()
                output << "    @CollectionTable(name=\"" << nameInCaps << "_X_" << fieldInCaps << "\", joinColumns={@JoinColumn(name=\"" << nameInCaps << "_" <<
                        idInCaps << "\")})" << System.lineSeparator()
            }
*/

            output << "    public " + type + " get" + firstUpperFN + "() {" << System.lineSeparator()
            output << "        return this." + field.getName() + ";" << System.lineSeparator()
            output << "    }" << System.lineSeparator()

            output << System.lineSeparator();
            output << "    public void set" + firstUpperFN + "( " + type + " " + field.getName() + ") {" << System.lineSeparator()
            output << "        this." + field.getName() + " = " + field.getName() + ";" << System.lineSeparator()
            output << "    }" << System.lineSeparator()

            //generate the setter to the entity from the impl for this field ----------------------------------------
            // type is the type of the field in the Entity class
            createSetLogicImplToEntity( transformTo, field, firstUpperFN );
            createSetLogicEntityToImpl( transformFrom, field, firstUpperFN );
            //-------------------------------------------------------------------------------------------------------
        }

        output << "" << System.lineSeparator()
        output << "}" << System.lineSeparator()

        writeTransformerTail(transformer, transformTo, transformFrom );
    }

    //return true/false if it is a list
    private boolean addListAnnotation(Field field, String columnName, def output, def proto) {
        boolean isList = false;

        //if its a collection we need specific annotations
        if (field.getType().getInterfaces()!=null) {
            for (Class iface : field.getType().getInterfaces()) {
                if (iface.getName().equals(Collection.class.getName())) {
                    isList = true;
                    break;
                }
            }
        }

        if (isList) {

            //determine the type encapsulated by the list
            Type type = field.getGenericType();
            if (type instanceof ParameterizedType) {
                ParameterizedType pt = (ParameterizedType)type;
                Type containee = pt.getActualTypeArguments()[0];
                String idtype = idFields.get(containee.typeName);

                String columnExtra = properties.get("entity.column.definition." + idtype);
                String col = "Column"
                if (columnExtra == null) {
                    output << "    @" << col << "(name=\"" << columnName << "\")" << System.lineSeparator()
                } else {
                    output << "    @" << col << "(name=\"" << columnName << "\" , columnDefinition=\"" + columnExtra + "\")" << System.lineSeparator()
                }
            }

            output << "    @ElementCollection(fetch=FetchType.LAZY)"<< System.lineSeparator()

            String nameInCaps = getColumnName(proto.getSimpleName());
            String idInCaps = getColumnName(idFieldName);
            String fieldInCaps = getColumnName(field.getName());

            output << "    @CollectionTable(name=\"" << nameInCaps << "_X_" << fieldInCaps << "\", joinColumns={@JoinColumn(name=\"" << nameInCaps << "_" <<
                    idInCaps << "\")})" << System.lineSeparator()

            return true;
        }
        return false;
    }

    private boolean addMapAnnotation(Field field, String columnName, def output, def proto) {
        //and if its a map almost the same
        boolean isMap =false;
        if (Map.class.getName().equals(field.getType().getTypeName())) isMap=true;
        if (!isMap && field.getType().getInterfaces()!=null) {
            for (Class iface : field.getType().getInterfaces()) {
                if (iface.getName().equals(Map.class.getName())) {
                    isMap=true;
                    break;
                }
            }
        }

        if (isMap) {
            //check if we need extra annotations for the key
            Type type = field.getGenericType();
            if (type instanceof ParameterizedType) {
                ParameterizedType pt = (ParameterizedType)type;
                Type containee = pt.getActualTypeArguments()[0];
                String idtype = idFields.get(containee.typeName);
                String columnExtra = properties.get("entity.column.definition." + idtype);
                String col = "Column"
                if (columnExtra == null) {
                    output << "    @" << col << "(name=\"" << columnName << "\")" << System.lineSeparator()
                } else {
                    output << "    @" << col << "(name=\"" << columnName << "\" , columnDefinition=\"" + columnExtra + "\")" << System.lineSeparator()
                }
            }

            output << "    @ElementCollection(fetch=FetchType.LAZY)"<< System.lineSeparator()

            String nameInCaps = getColumnName(proto.getSimpleName());
            String idInCaps = getColumnName(idFieldName);
            String fieldInCaps = getColumnName(field.getName());

            output << "    @MapKeyColumn(name=\"MAP_KEY\")" << System.lineSeparator()
            output << "    @CollectionTable(name=\"" << nameInCaps << "_X_" << fieldInCaps << "\", joinColumns={@JoinColumn(name=\"" << nameInCaps << "_" <<
                    idInCaps << "\")})" << System.lineSeparator()
            return true;
        }

        return false;
    }

    private void iterateGenerics(Type type, Consumer<Type> classConsumer) {
        if (type instanceof ParameterizedType) {
            ParameterizedType p = (ParameterizedType)type;
            classConsumer.accept(p);
            for(Type t : p.getActualTypeArguments()) {
                classConsumer.accept(t);
                if (t instanceof ParameterizedType)
                { iterateGenerics((ParameterizedType)t, classConsumer); }
            }
        }
    }

    public String swapType(Type type) {
        if (type instanceof ParameterizedType) {
            ParameterizedType p = (ParameterizedType) type;
            String retval = swapTypeName(p.getRawType().getTypeName());
            retval += "<";
            //then do the parameters
            boolean first = true;
            for (Type t : p.getActualTypeArguments()) {
                if (!first) retval = retval + ",";
                retval = retval + swapType(t);
                first = false;
            }
            retval += ">";
            return retval;
        }
        String retval = swapTypeName(type.getTypeName());
        return retval;
    }

    public String swapTypeName(String fieldName) {

        String newFieldName = fieldName;
        if (newFieldName.contains(implPackage)) {
            //in this case we need to swap it for the repository id field type
            //as it's a reference
            String urgName = idFields.get(fieldName);
            if (urgName!=null) {
                newFieldName = urgName;
            }
        }

        String propswap = properties.get("entity.swap.type." + newFieldName);
        if (propswap!=null) newFieldName = propswap;


        if ("int".equals(newFieldName)) newFieldName = "Integer";
        if ("long".equals(newFieldName)) newFieldName = "Long";
        if ("float".equals(newFieldName)) newFieldName = "Float";
        if ("double".equals(newFieldName)) newFieldName = "Double";
        if ("boolean".equals(newFieldName)) newFieldName= "Boolean"; //perhaps

        return newFieldName;
    }

    public String getColumnName(String fieldName) {
        fieldName = fieldName.replaceAll(/([a-z])([A-Z])/) { all, first, second ->
            first + "_" + second
        }

        return fieldName.toUpperCase();
    }

    private void createSetLogicImplToEntity(def transformer, Field field, String firstUpperFN) {
        Type type = field.getGenericType();

        //need to transform the fieldname
        String fufn = "get" + firstUpperFN;
        if (field.getType().getTypeName().equalsIgnoreCase("Boolean"))
        {
            fufn = field.getName();
        }

        String fieldName = "impl." + fufn + "()";

        //prefix need to be controlled by annotations TODO
        transformer << "        ";
        if (!field.getType().isPrimitive())
            transformer << "if (impl." << fufn << "()!=null) "
        transformer << "entity.set" + firstUpperFN + "("

        recurseSetLogicImplToEntity(transformer, type, fieldName);

        transformer << ");" << System.lineSeparator();
    }

    private void recurseSetLogicImplToEntity(def transformer, Type type, String fieldName) {

        String entityType = swapType(type);

        String typeName= type.getTypeName();
        if (type instanceof ParameterizedType) {
            typeName = ((ParameterizedType)type).getRawType().getTypeName();
        }

        if (typeName.contains(implPackage)) {
            String ref = type.getTypeName() + "Reference";

            //sometimes the repository id is eg unique id but we need to convert it to eg byte[]
            String reptype =idFields.get(type.getTypeName());
            String converter = properties.get("entity.type.converter." + reptype);
            if (converter!=null) {
                //transformer << converter;

                //getting pretty hideous
                //we need to
                //(1) establish the name of a linking method for the conversion
                //(2) add the name to a set of such names
                //(3) use that method plus the config to convert the type
                GenerateConverterName converterName = GenerateConverterName.createHook( reptype, entityType );

                //add to the set of known converternames
                converterNames.add(converterName);
                transformer << converterName.getConverterMethodName() << "( " <<
                        "((" + ref + ")" + fieldName + ").getRepositoryId()" << ", " <<
                        converter << ")";

            } else {
                //no conversion needed
                transformer << "((" + ref + ")" + fieldName + ").getRepositoryId()";
            }

        } else {

            if (type instanceof ParameterizedType) {
                ParameterizedType pt = (ParameterizedType) type;
                String rawname = pt.getRawType().getTypeName();

                handleListImplToEntity(transformer, rawname, fieldName, pt);
                handleMapImplToEntity( transformer, rawname, fieldName, pt);

            }
            else {
                String converter = properties.get("entity.type.converter." + type.getTypeName());
                if (converter != null) {
                    //we need the type associated with fieldName ...
                    GenerateConverterName converterName = GenerateConverterName.createHook( type.getTypeName(), entityType );
                    converterNames.add(converterName);
                    transformer << converterName.getConverterMethodName() << "( " <<
                    fieldName << ", " << converter << ")";
                } else {
                    transformer << fieldName;
                }
            }
        }
    }

    private void handleListImplToEntity( def transformer, String rawName, String fieldName, ParameterizedType parameterizedType) {
        try {

            Class c = Class.forName(rawName);
            boolean list = false;
            if (List.class.getName().equals(c.getName())) list = true;
            for(Class iface: c.getInterfaces()) {
                if (List.class.getName().equals(iface.getName())) {
                    list = true;
                    break;
                }
            }

            if (list) {
                //preamble
                transformer << fieldName << " == null ? null : "+ fieldName + ".stream().map( item -> " << System.lineSeparator();
                transformer << "            ";

                //then recurse into the type
                for (Type t : parameterizedType.getActualTypeArguments()) {
                    recurseSetLogicImplToEntity(transformer,t, "item");
                }

                //then postamble
                transformer << System.lineSeparator() << "        ).collect(Collectors.toList())"

            }

        } catch(Exception e) {
            e.printStackTrace();
        }
    }

    private void handleMapImplToEntity( def transformer, String rawName, String fieldName, ParameterizedType parameterizedType) {
        try {
            Class c = Class.forName(rawName);
            boolean map = false;
            if (Map.class.getName().equals(c.getName())) map = true;
            for(Class iface: c.getInterfaces()) {
                if (Map.class.getName().equals(iface.getName())) {
                    map = true;
                    break;
                }
            }

            if (map) {
                //preamble
                transformer << fieldName + " ==null ? null : " << fieldName + ".entrySet().stream().collect(Collectors.toMap( " << System.lineSeparator()
                transformer << "            e -> "

                //then recurse into the type
                Type keytype = parameterizedType.getActualTypeArguments()[0];
                recurseSetLogicImplToEntity(transformer, keytype, "e.getKey()");
                transformer << "," << System.lineSeparator()
                transformer << "            e-> ";
                Type valuetype = parameterizedType.getActualTypeArguments()[1];
                recurseSetLogicImplToEntity(transformer, valuetype,"e.getValue()");

                //then postamble
                transformer << "))"

            }

        } catch(Exception e) {}
    }

    private void writeTransformerHeader(def transformer, Class proto) {

        transformer << "package " + jpaEntityPackage + ";" << System.lineSeparator()
        transformer << "" << System.lineSeparator();
        transformer << "//DO NOT MODIFY, this class was generated by xxx " << System.lineSeparator();
        transformer << ""<< System.lineSeparator();
        transformer << "import java.util.stream.Collectors;" << System.lineSeparator()
        transformer << "import transgenic.lauterbrunnen.lateral.domain.UniqueId;" << System.lineSeparator()
        transformer << "import java.util.function.Function;" << System.lineSeparator();
        transformer << ""<< System.lineSeparator();
        transformer << "public class " << proto.getSimpleName() << "EntityTransformer {" << System.lineSeparator();
        transformer << "" << System.lineSeparator();
//        transformer << "    public static void transform(" << proto.getSimpleName() << "Entity entity, " <<
//                implPackage << "." << proto.getSimpleName() << "Impl impl) {" << System.lineSeparator();
    }

    private void writeTransformToDeclaration(def transformTo, Class proto) {
        transformTo << "    public static void transform(" << proto.getSimpleName() << "Entity entity, " <<
                implPackage << "." << proto.getSimpleName() << "Impl impl) {" << System.lineSeparator();
    }

    private void writeTransformFromDeclaration( def transformFrom, Class proto) {
        transformFrom << "    public static void transform(" << implPackage << "." << proto.getSimpleName() << "Impl impl," <<
                proto.getSimpleName() << "Entity entity) {" << System.lineSeparator();
    }

    private void writeTransformerTail(def transformer, def transformTo, def transformFrom) {
        transformer << transformTo << System.lineSeparator() << "    }" << System.lineSeparator() << System.lineSeparator();
        transformer << transformFrom << System.lineSeparator() << "    }" << System.lineSeparator() << System.lineSeparator();

        //write all the hooks
        for(GenerateConverterName converterName: converterNames) {
            converterName.writeHookMethod( transformer );
        }

        transformer << "}" << System.lineSeparator()
    }

    //--------------------------------------------------------------------------------------------
    //Field is the IMPL field here, not the entity field
    private void createSetLogicEntityToImpl(def transformer, Field field, String firstUpperFN) {
        Type type = field.getGenericType();

        //need to transform the fieldname
        String fufn = "get" + firstUpperFN;
        if (field.getType().getTypeName().equalsIgnoreCase("Boolean"))
        {
            //fufn = field.getName();
            firstUpperFN = firstUpperFN.replaceFirst("Is", "");
        }

        String fieldName = "entity." + fufn + "()";

        //prefix need to be controlled by annotations TODO
        transformer << "        ";
        if (!field.getType().isPrimitive())
            transformer << "if (entity." << fufn << "()!=null) "
        transformer << "impl.set" + firstUpperFN + "("

        recurseSetLogicEntityToImpl(transformer, type, fieldName);

        transformer << ");" << System.lineSeparator();
    }

    private void recurseSetLogicEntityToImpl(def transformer, Type type, String fieldName) {

        String entityType = swapType(type);

        String typeName= type.getTypeName();
        if (type instanceof ParameterizedType) {
            typeName = ((ParameterizedType)type).getRawType().getTypeName();
        }

        //Different here. We need to look at the type in the Impl not the type in the entity
        //to know if we need to convert, eg, byte[] to new ObjectReference(byte[] bb)
        if (typeName.contains(implPackage)) {
            String ref = type.getTypeName() + "Reference";

            //(2) fine if there is a conversion then let's convert
            //sometimes the repository id is eg unique id but we need to convert it to eg byte[]
            String reptype = idFields.get(type.getTypeName());
            String converter = properties.get("entity.type.reverse.converter." + reptype);
            if (converter!=null) {
                //we need to
                //(1) establish the name of a linking method for the conversion
                //(2) add the name to a set of such names
                //(3) use that method plus the config to convert the type
                GenerateConverterName converterName = GenerateConverterName.createHook( entityType, reptype);

                //add to the set of known converternames
                converterNames.add(converterName);
                transformer << "new " << ref << "( "
                transformer << converterName.getConverterMethodName() << "( " <<
                        fieldName + ", " <<
                        converter << "))";

            } else {
                //(1) if there is no conversion needed we just do
                // eg impl.setTeacher( new TeacherReference( entity.getTeacher() ) )
                transformer << "new " << ref << "( " <<  fieldName << " )"
            }

        } else {

            if (type instanceof ParameterizedType) {
                ParameterizedType pt = (ParameterizedType) type;
                String rawname = pt.getRawType().getTypeName();

                handleListEntityToImpl(transformer, rawname, fieldName, pt);
                handleMapEntityToImpl( transformer, rawname, fieldName, pt);

            }
            else {
                String converter = properties.get("entity.type.reverse.converter." + type.getTypeName());
                if (converter != null) {
                    //we need the type associated with fieldName ...
                    GenerateConverterName converterName = GenerateConverterName.createHook( entityType, type.getTypeName() );
                    converterNames.add(converterName);
                    transformer << converterName.getConverterMethodName() << "( " <<
                            fieldName << ", " << converter << ")";
                } else {
                    transformer << fieldName;
                }
            }
        }
    }

    private void handleListEntityToImpl( def transformer, String rawName, String fieldName, ParameterizedType parameterizedType) {
        try {

            Class c = Class.forName(rawName);
            boolean list = false;
            if (List.class.getName().equals(c.getName())) list = true;
            for(Class iface: c.getInterfaces()) {
                if (List.class.getName().equals(iface.getName())) {
                    list = true;
                    break;
                }
            }

            if (list) {
                //preamble
                transformer << fieldName << " == null ? null : "+ fieldName + ".stream().map( item -> " << System.lineSeparator();
                transformer << "            ";

                //then recurse into the type
                for (Type t : parameterizedType.getActualTypeArguments()) {
                    recurseSetLogicEntityToImpl(transformer,t, "item");
                }

                //then postamble
                transformer << System.lineSeparator() << "        ).collect(Collectors.toList())"

            }

        } catch(Exception e) {
            e.printStackTrace();
        }
    }

    private void handleMapEntityToImpl( def transformer, String rawName, String fieldName, ParameterizedType parameterizedType) {
        try {
            Class c = Class.forName(rawName);
            boolean map = false;
            if (Map.class.getName().equals(c.getName())) map = true;
            for(Class iface: c.getInterfaces()) {
                if (Map.class.getName().equals(iface.getName())) {
                    map = true;
                    break;
                }
            }

            if (map) {
                //preamble
                transformer << fieldName + " ==null ? null : " << fieldName + ".entrySet().stream().collect(Collectors.toMap( " << System.lineSeparator()
                transformer << "            e -> "

                //then recurse into the type
                Type keytype = parameterizedType.getActualTypeArguments()[0];
                recurseSetLogicEntityToImpl(transformer, keytype, "e.getKey()");
                transformer << "," << System.lineSeparator()
                transformer << "            e-> ";
                Type valuetype = parameterizedType.getActualTypeArguments()[1];
                recurseSetLogicEntityToImpl(transformer, valuetype,"e.getValue()");

                //then postamble
                transformer << "))"

            }

        } catch(Exception e) {}
    }
}
