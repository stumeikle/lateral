package ${outputPackage};

//DO NOT MODIFY, this class was generated by xxx

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import ${inputPackage}.${protoName}Impl;
import ${inputPackage}.${protoName}Repository;
import transgenic.lauterbrunnen.lateral.domain.*;
import ${domainPackage}.${diContext}Context;
import static transgenic.lauterbrunnen.lateral.Lateral.inject;

public class HM${protoName}RepositoryImpl implements ${protoName}Repository {

    private volatile static int nextUpdateId=1;
    private final static ConcurrentHashMap<${repoIdType}, ${protoName}Impl> cache = new ConcurrentHashMap<>();
    private Repository repository = inject(Repository.class, ${diContext}Context.class);

    @Override
    public void create(${protoName}Impl ${lcProtoName}Impl) throws PersistenceException {
        cache.put(${lcProtoName}Impl.getRepositoryId(), ${lcProtoName}Impl);
    }

    @Override
    public void persist(${protoName}Impl ${lcProtoName}Impl) throws PersistenceException{
        create(${lcProtoName}Impl);
    }

    @Override
    public void persistAll(Collection<EntityImpl> persistCollection)  throws PersistenceException{
        //Nothing clever for now
        //Entities here could be a variety of types
        for(EntityImpl impl: persistCollection) {
            CRUDRepository repo = repository.getRepositoryForClass(impl.getClass());
            repo.persist(impl);
        }
     }

    @Override
    public ${protoName}Impl retrieve(${repoIdType} id) {
        ${protoName}Impl retval = (${protoName}Impl) cache.get(id);
        return retval;
    }

    @Override
    public void delete(${repoIdType} id) {
        cache.remove(id);
    }

    @Override
    public void update(${protoName}Impl ${lcProtoName}Impl) throws PersistenceException {
        //we need a unique identifier for the update
        //do that the dbdumpers can agree which updates have been persisted
        ${lcProtoName}Impl.setUpdateId(nextUpdateId++);

#if( $optimisticLocking)
        ${protoName}Impl previous = retrieve(${lcProtoName}Impl.getRepositoryId());
        if (! cache.replace(${lcProtoName}Impl.getRepositoryId(), previous, ${lcProtoName}Impl)) { //returns true/false
            throw new OptimisticLockingException(${protoName}Impl.class, ${lcProtoName}Impl.getRepositoryId());
        }
#else
        cache.put(${lcProtoName}Impl.getRepositoryId(), ${lcProtoName}Impl);
#end
    }

    //need to catch optimistic locking exceptions and concatenate and then through persistence exception
    @Override
    public void updateAll(Collection<EntityImpl> updateCollection) throws PersistenceException {
        OptimisticLockingException first = null, last = null;

        for(EntityImpl impl: updateCollection) {
            CRUDRepository repo = repository.getRepositoryForClass(impl.getClass());
            try {
                repo.update(impl);
            } catch(OptimisticLockingException ole) {
                if (first==null) first = ole;
                if (last==null) last = first;
                last.add(ole);
                last=ole;
            }
            catch(PersistenceException e) {
                //in this case throw
                throw e;
            }
        }

        if (first!=null) throw first;
    }


    @Override
    public Collection<${protoName}Impl> retrieveAll() {
        List<${protoName}Impl> all = new ArrayList<>(cache.size());

        for(Object id : cache.keySet()) {
            all.add((${protoName}Impl)cache.get(id));
        }
        return all;
    }

    @Override
    public Collection<${protoName}Impl> search(String predicate) {
        return null;
    }

    @Override
    public Collection<${repoIdType}> retrieveKeys() {
        return cache.keySet();
    }
}
