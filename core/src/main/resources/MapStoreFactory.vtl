package ${cachePackage};

//DO NOT MODIFY, this class was generated by xxx

import com.hazelcast.core.MapStoreFactory;
import ${implPackage}.*;
import com.hazelcast.core.MapLoader;
import transgenic.lauterbrunnen.lateral.di.ApplicationDI;
import transgenic.lauterbrunnen.lateral.cache.hazelcast.HCMapStoreFactory;
import transgenic.lauterbrunnen.lateral.di.DefaultImpl;
import transgenic.lauterbrunnen.lateral.persist.hazelcast.DummyMapStore;
import transgenic.lauterbrunnen.lateral.persist.hazelcast.HCMapStoreRT;
import transgenic.lauterbrunnen.lateral.persist.hazelcast.HCMapStoreRWT;
import transgenic.lauterbrunnen.lateral.persist.hazelcast.HCMapStoreWT;
import static transgenic.lauterbrunnen.lateral.di.ApplicationDI.inject;
import java.util.Properties;

@DefaultImpl
public class HCMapStoreFactoryImpl implements HCMapStoreFactory{

    //should be configurable. write-through, read-through
    private MapStoreFactory[] factories = {this::noReadNoWrite, this::readNoWrite, this::writeNoRead,
                                           this::readAndWrite};
    private int index = 0;

    @Override
    public MapLoader<Object, Object> newMapStore(String s, Properties properties) {
        return factories[index].newMapStore(s, properties);
    }

    @Override
    public void setWriteThrough(boolean writeThrough) {
        if (writeThrough) index+=2;
    }

    //write through, write behind differ only in the configurable write delay
    @Override
    public void setWriteBehind(boolean writeBehind) {
        if (writeBehind) index+=2;
    }

    @Override
    public void setReadThrough(boolean readThrough) {
        if (readThrough) index++;
    }

    public MapLoader<Object, Object> noReadNoWrite(String s, Properties properties) {
        return new DummyMapStore();
    }

    //Read through means fulfill cache misses from an external store, implement mapload
    //Write though or Write behind means write cache changes to the external store
        public MapLoader<Object, Object> readNoWrite(String s, Properties properties) {

#foreach( $name in $allNames )
        if ("${name}".equals(s)) {
            ${name}Retriever retriever = inject(${name}Retriever.class);
            if (retriever==null) retriever = new ${name}RetrieverImplDirect();
            return new HCMapStoreRT(retriever);
        }
#end

        return null;
    }

#if ( $generateDirect )
    public MapLoader<Object, Object> writeNoRead(String s, Properties properties) {
#foreach( $name in $allNames )
        if ("${name}".equals(s)) {
            ${name}Persister persister = inject(${name}Persister.class);
            if (persister==null) persister = new ${name}PersisterImplDirect();
            return new HCMapStoreWT(persister);
        }
#end

        return null;
    }
#else
    public MapLoader<Object, Object> writeNoRead(String s, Properties properties) {
       return new DummyMapStore();
    }
#end

#if ( $generateDirect )
    public MapLoader<Object, Object> readAndWrite(String s, Properties properties) {
#foreach( $name in $allNames )
        if ("${name}".equals(s)) {
            ${name}Persister persister = inject(${name}Persister.class);
            if (persister==null) persister = new ${name}PersisterImplDirect();
            ${name}Retriever retriever = inject(${name}Retriever.class);
            if (retriever==null) retriever = new ${name}RetrieverImplDirect();
            return new HCMapStoreRWT(retriever,persister);
        }
#end

        return null;
    }
#else
    public MapLoader<Object, Object> readAndWrite(String s, Properties properties) {
        return new DummyMapStore();
    }
#end

}
