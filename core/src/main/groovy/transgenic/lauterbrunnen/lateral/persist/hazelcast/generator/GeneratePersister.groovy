package transgenic.lauterbrunnen.lateral.persist.hazelcast.generator

import transgenic.lauterbrunnen.lateral.domain.DomainProtoManager

/**
 * Created by stumeikle on 11/06/16.
 */
class GeneratePersister {

    protected String basePath;
    protected String implPackage;
    protected String cachePackage;
    protected String entityPackage;
    protected DomainProtoManager domainProtoManager;
    protected String diContext;

    String getBasePath() {
        return basePath
    }

    void setDomainProtoManager(DomainProtoManager domainProtoManager1) {
        this.domainProtoManager = domainProtoManager1;
    }

    void setBasePath(String basePath) {
        this.basePath = basePath
    }

    String getImplPackage() {
        return implPackage
    }

    void setImplPackage(String implPackage) {
        this.implPackage = implPackage
    }

    void setDiContext(String diContext){
        this.diContext = diContext;
    }

    String getCachePackage() {
        return cachePackage
    }

    void setCachePackage(String cachePackage) {
        this.cachePackage = cachePackage
    }

    void setEntityPackage(String entityPackage) {
        this.entityPackage = entityPackage
    }

    public void generate(Class proto) {
        def fn = basePath + "/" + cachePackage.replaceAll("\\.","/") + "/" + proto.getSimpleName() + "PersisterImplDirect.java";
        println "Writing " + fn;
        def output = new File(fn);

        output << "package " + cachePackage + ";" << System.lineSeparator()
        output << "" << System.lineSeparator();
        output << "//DO NOT MODIFY, this class was generated by xxx " << System.lineSeparator();
        output << ""<< System.lineSeparator();

        String entityName = domainProtoManager.getEntityName(proto) + "Entity";
        String entityTransformer = entityName + "Transformer";
        String entity = entityName;

        output << "import " << implPackage << ".*;" << System.lineSeparator();

        String subPackage = domainProtoManager.getSubPackageForProto(proto.getSimpleName());
        if (!"".equals(subPackage)) {
            output << "import " << implPackage << "." << subPackage << ".*;" << System.lineSeparator();
        }

        output << "import " << entityPackage << "." << entityName << ";" << System.lineSeparator()
        output << "import " << entityPackage << "." << entityName << "Transformer;" << System.lineSeparator()
        output << "import transgenic.lauterbrunnen.lateral.persist.Persister;" << System.lineSeparator()+
                  "import transgenic.lauterbrunnen.lateral.persist.TransactionManager;"<< System.lineSeparator()
        output << "import transgenic.lauterbrunnen.lateral.di.DefaultImpl;" << System.lineSeparator()
        output << "import transgenic.lauterbrunnen.lateral.di.DIContext;" << System.lineSeparator()
        output << "import java.util.Collection;" << System.lineSeparator +
                "import java.util.Map;" << System.lineSeparator +
                "import static transgenic.lauterbrunnen.lateral.Lateral.inject;"  << System.lineSeparator;
        output << "" << System.lineSeparator();
        
        String implPersister = proto.getSimpleName() + "PersisterImplDirect";
        String impl = proto.getSimpleName() + "Impl";

        String implLC = impl.substring(0,1).toLowerCase() + impl.substring(1);
        String entityLC = entity.substring(0,1).toLowerCase() + entity.substring(1);
        output << "@DefaultImpl" << System.lineSeparator();
        output << "@DIContext(" << diContext << "Context.class)" << System.lineSeparator();
        output << "public class " << implPersister << " implements " << proto.getSimpleName() << "Persister {" << System.lineSeparator() +
                "    private TransactionManager transactionManager=inject(TransactionManager.class," << diContext << "Context.class);" << System.lineSeparator() << System.lineSeparator() +
                "    @Override" << System.lineSeparator() +
                "    //This method called from hc map store for both persists AND updates :(" << System.lineSeparator() +
                "    public void persist(Object object) {" << System.lineSeparator() +
                "        if (!(object instanceof " << impl << ")) return;" << System.lineSeparator() +
                "" << System.lineSeparator() +
                "        " << impl << " " << implLC << " = (" << impl << ")object;" << System.lineSeparator() +
                "        " << entity << " " << entityLC << " = new " << entity << "();" << System.lineSeparator() +
                "        " << entityTransformer << ".transform( " << entityLC << ", " << implLC << " );" << System.lineSeparator() +
                "        transactionManager.runInTransactionalContext(em -> {" << System.lineSeparator() +
                "            em.merge(" << entityLC << ");" << System.lineSeparator() +
                "        });" << System.lineSeparator() +
                "    }" << System.lineSeparator() +
                "    @Override" << System.lineSeparator +
                "    public void persistAll(Map<Object, Object> map) {" << System.lineSeparator +
                "        //agreed non ideal TODO" << System.lineSeparator +
                "        for(Object o: map.values()) {" << System.lineSeparator +
                "            persist(o);" << System.lineSeparator +
                "        }" << System.lineSeparator +
                "    }" << System.lineSeparator() +
                "" << System.lineSeparator() +
                "    //This method never called. HC map store does not differentiate between store and update"<< System.lineSeparator() +
                "    @Override" << System.lineSeparator() +
                "    public void update(Object object) {" << System.lineSeparator() +
                "        if (!(object instanceof " << impl << ")) return;" << System.lineSeparator() +
                "        " << impl << " " << implLC << " = (" << impl << ")object;" << System.lineSeparator() +
                "" << System.lineSeparator() +
                "        transactionManager.runInTransactionalContext(em -> {" << System.lineSeparator() +
                "            " << entity << " " << entityLC << " = em.find( " << entity << ".class, " << implLC << ".getRepositoryId() );" << System.lineSeparator() +
                "            " << entityTransformer << ".transform(" << entityLC << ", " << implLC << ");" << System.lineSeparator() +
                "        });" << System.lineSeparator() +
                "    }" << System.lineSeparator() +
                "" << System.lineSeparator() +
                "    @Override" << System.lineSeparator() +
                "    public void remove(Object object) {" << System.lineSeparator() +

                //WARNING, could be we need to convert the object repository id here

                "        if (!(object instanceof " << impl << ")) return;" << System.lineSeparator() +
                "        " << impl << " " << implLC << " = (" << impl << ")object;" << System.lineSeparator() +
                "" << System.lineSeparator() +
                "        transactionManager.runInTransactionalContext(em -> {" << System.lineSeparator() +
                "            " << entity << " " << entityLC << " = em.find( " << entity << ".class, " << implLC << ".getRepositoryId() );" << System.lineSeparator() +
                "            em.remove(" << entityLC << ");" << System.lineSeparator() +
                "        });" << System.lineSeparator() +
                "    }"<< System.lineSeparator()<< System.lineSeparator() +
                "    private void removeByKey(Object key) {" << System.lineSeparator +
                "        transactionManager.runInTransactionalContext(em -> {" << System.lineSeparator +
                "            " << entity << " " << entityLC << " = em.find( " << entity << ".class, key );" << System.lineSeparator +
                "            em.remove(" << entityLC << ");" << System.lineSeparator +
                "        });" << System.lineSeparator +
                "    }" << System.lineSeparator +
                "" << System.lineSeparator +
                "    @Override" << System.lineSeparator +
                "    public void removeAll(Collection<Object> collection) {" << System.lineSeparator +
                "        //agreed non ideal TODO" << System.lineSeparator +
                "        for(Object o: collection) {" << System.lineSeparator +
                "            removeByKey(o);" << System.lineSeparator +
                "        }" << System.lineSeparator +
                "    }" << System.lineSeparator
        output << "}" << System.lineSeparator()
    }
}
