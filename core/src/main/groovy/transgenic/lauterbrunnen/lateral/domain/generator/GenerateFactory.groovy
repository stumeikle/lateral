package transgenic.lauterbrunnen.lateral.domain.generator

import transgenic.lauterbrunnen.lateral.domain.OptimisticLocking
import transgenic.lauterbrunnen.lateral.domain.UniqueId

import java.lang.annotation.Annotation
import java.lang.reflect.Field

/**
 * Created by stumeikle on 04/06/16.
 */
class GenerateFactory extends GenerateRepo {

    private ClassLoader classLoader;
    private boolean optimisticLocking; //set internally
    private boolean sequencesPresent; //est internally
    private List<String> sequenceFields; //set internally
    Set<String> protoSubPackages;
    String protoPackage;

    public void setClassLoader(ClassLoader classLoader) {
        this.classLoader = classLoader;
    }

    public void generateFactory() {
        def fn = basePath + "/" + outputPackage.replaceAll("\\.", "/") + "/DefaultFactoryImpl.java";
        println "Writing " + fn;
        def output = new File(fn);

        output << "package " + outputPackage + ";" << System.lineSeparator()
        output << "" << System.lineSeparator();
        output << "//DO NOT MODIFY, this class was generated by xxx " << System.lineSeparator();
        output << "" << System.lineSeparator();
        output << "import transgenic.lauterbrunnen.lateral.di.DIContext;" << System.lineSeparator()
        output << "import transgenic.lauterbrunnen.lateral.di.DefaultImpl;" << System.lineSeparator()
        output << "import transgenic.lauterbrunnen.lateral.domain.*;" << System.lineSeparator()
        output << "import java.util.Map;" << System.lineSeparator()
        output << "import java.util.HashMap;" << System.lineSeparator()
        output << "import java.util.function.Supplier;" << System.lineSeparator()
        output << "import static transgenic.lauterbrunnen.lateral.Lateral.inject;" << System.lineSeparator();
        output << "" << System.lineSeparator()

        if (protoSubPackages.size()>0) {
            for(String protoSubPackage : protoSubPackages) {
                output << "import " << outputPackage << "." << protoSubPackage << ".*;" << System.lineSeparator();
            }
            output << "" << System.lineSeparator();
        }

        output << "@DefaultImpl" << System.lineSeparator()
        output << "@DIContext(" + diContext + "Context.class)" << System.lineSeparator()
        output << "public class DefaultFactoryImpl implements Factory {" << System.lineSeparator()
        output << "" << System.lineSeparator()
//        output << "    private final Map<Class, CRUDRepository> class2RepoMap = new HashMap<>();" << System.lineSeparator()
        output << "    private final Map<Class, Supplier>       class2Constructor = new HashMap<>();" << System.lineSeparator()
        if (sequencesPresent) {
            output << "    private static Repository repository=null;" << System.lineSeparator();
        }
        output << "" << System.lineSeparator()
        output << "    public DefaultFactoryImpl() {" << System.lineSeparator()


        for (Class proto : prototypeClasses) {
//            output << "        class2RepoMap.put(" << proto.getSimpleName() << ".class, inject(" <<
//                    proto.getSimpleName() << "Repository.class, " + diContext + "Context.class));" << System.lineSeparator()
//            output << "        class2RepoMap.put(" << proto.getSimpleName() << "Impl.class, inject(" <<
//                    proto.getSimpleName() << "Repository.class, " + diContext + "Context.class));" << System.lineSeparator()
            output << "        class2Constructor.put(" + proto.getSimpleName() + ".class, DefaultFactoryImpl::create" <<
                    proto.getSimpleName() << ");" << System.lineSeparator()
        }
        output << "    }" << System.lineSeparator()

//        output << "" << System.lineSeparator()
//        output << "    public CRUDRepository getRepositoryForClass(Class clazz) {" << System.lineSeparator()
//        output << "        return class2RepoMap.get(clazz);" << System.lineSeparator()
//        output << "    }" << System.lineSeparator()

        output << "" << System.lineSeparator()
        output << "    public <T> T create(Class<T> clazz) {" << System.lineSeparator()
        output << "        Supplier<T> supplier = class2Constructor.get(clazz);" << System.lineSeparator()
        output << "        return (supplier!=null ? supplier.get() : null);" << System.lineSeparator()
        output << "    }" << System.lineSeparator()

        boolean anyClassWithSequences=false;

        for (Class proto : prototypeClasses) {

            String lc1Name = proto.getSimpleName().substring(0, 1).toLowerCase() + proto.getSimpleName().substring(1);

            checkForSequencesAndOptimisticLocking(proto);

            output << "" << System.lineSeparator()
            output << "    public static " << proto.getSimpleName() << " create" << proto.getSimpleName() << "() {" << System.lineSeparator()
            output << "        " << proto.getSimpleName() << "Impl " << lc1Name << "Impl = new " << proto.getSimpleName() <<
                    "Impl();" << System.lineSeparator();

            if (sequencesPresent) {
                anyClassWithSequences=true;
                output << "        try {" << System.lineSeparator();

                for (String field : sequenceFields) {
                    output << "            " << lc1Name << "Impl.set" << field << "((int)incrementSequence(\"" << proto.getSimpleName() << "_" << field << "\"));" << System.lineSeparator();
                }

                output << "        } catch (PersistenceException e) {" << System.lineSeparator();
                output << "            return null;" << System.lineSeparator();
                output << "        }" << System.lineSeparator();
            }

            //if the idclass is UniqueId we can assign it here
            List<Field> allFields = getAllFields(proto);
            setIdField(allFields);

            if (idField != null && idField.getType().getName().equals(UniqueId.class.getName())) {
                output << "        " << lc1Name << "Impl.set" << convertFirstCharToUpper(idField.getName()) << "( UniqueId.generate() );" << System.lineSeparator()
            } else {
                if (idField == null) {
                    output << "        " << lc1Name << "Impl.setRepositoryId( UniqueId.generate() );" << System.lineSeparator()
                }
            }

            output << "        return " << lc1Name << "Impl;" << System.lineSeparator()
            output << "    }" << System.lineSeparator()

        }

        //boilerplate
        if (anyClassWithSequences) {

            output << System.lineSeparator();
            //not sure about this #circular dependencies?
            output << "    private static Repository repository;" << System.lineSeparator();
            output << "    protected static long incrementSequence(String name) throws PersistenceException{" << System.lineSeparator();
            output << "        if (repository==null) repository = inject(Repository.class, " << diContext << "Context.class);"<< System.lineSeparator();
            output << "        _Sequence sequence = repository.retrieve(_Sequence.class, name);" << System.lineSeparator();
            output << "" << System.lineSeparator();
            output << "        //If there is no sequence, create a new one" << System.lineSeparator();
            output << "        if (sequence==null) {" << System.lineSeparator();
            output << "            sequence = create_Sequence();" << System.lineSeparator();
            output << "            sequence.setName(name);" << System.lineSeparator();
            output << "            sequence.setValue(0);" << System.lineSeparator();
            output << "            repository.persist(sequence);" << System.lineSeparator();
            output << "        }" << System.lineSeparator();
            output << "" << System.lineSeparator();
            output << "        int retryCount = 0;" << System.lineSeparator();
            output << "        long value=0;" << System.lineSeparator();
            output << "        do {" << System.lineSeparator();
            output << "            try {" << System.lineSeparator();
            output << "                value = sequence.getValue()+1;" << System.lineSeparator();
            output << "                sequence.setValue(value);" << System.lineSeparator();
            output << "                repository.update(sequence);" << System.lineSeparator();
            output << "            } catch (PersistenceException e) {" << System.lineSeparator();
            output << "                if (e instanceof OptimisticLockingException) {" << System.lineSeparator();
            output << "                    //retry a few times" << System.lineSeparator();
            output << "                    retryCount++;" << System.lineSeparator();
            output << "                    if (retryCount>=3) throw e;" << System.lineSeparator();
            output << "                }" << System.lineSeparator();
            output << "                else throw e;" << System.lineSeparator();
            output << "            }" << System.lineSeparator();
            output << "        }while(retryCount>0 && retryCount<3);" << System.lineSeparator();
            output << "        return value;" << System.lineSeparator();
            output << "    }" << System.lineSeparator();
        }
        output << "}" << System.lineSeparator()
    }

    private void checkForSequencesAndOptimisticLocking(Class proto) {

        //20200918 need to consider subpackages now
        //This means we need to change outputPackage to include the extras
        String classOutputPackage = outputPackage + proto.getName().substring(protoPackage.length());
        classOutputPackage = classOutputPackage.replace("." + proto.getSimpleName(),"");

        //check the annotations on the class for optimistic locking
        optimisticLocking = false;
        String implClassName = classOutputPackage + "." + proto.getSimpleName() + "Impl";

        Class implClass = null;
        try {
            implClass = classLoader.loadClass(implClassName);
            for (Annotation note : implClass.getAnnotations()) {
                if (note.annotationType().getName().equals(OptimisticLocking.class.getName())) optimisticLocking = true;
            }
        } catch(Exception e) {
            e.printStackTrace()
        }

        sequencesPresent=false;
        sequenceFields = new ArrayList<>();
        for(Field f: implClass.getDeclaredFields()) {
            boolean found=false;
            for(Annotation note: f.getAnnotations()) {
                if (note.annotationType().getName().equals(transgenic.lauterbrunnen.lateral.domain.Sequence.class.getName())) {
                    found=true;break;
                }
            }
            if (found) {
                sequencesPresent=true;
                String fieldName = f.getName();
                fieldName = fieldName.substring(0,1).toUpperCase() + fieldName.substring(1);
                sequenceFields.add(fieldName);
            }
        }

    }
}

/*
    public static Track createTrack()  {
        try {
            TrackImpl trackImpl = new TrackImpl();
            trackImpl.setId((int) incrementSequence("Track_Id"));
            return trackImpl;
        } catch (PersistenceException e) {
            return null;
        }
    }

    //#if ($sequencesPresent)
//#foreach( $field in $sequenceFields )
//        ${lcProtoName}Impl.set${field}((int)incrementSequence("${protoName}_${field}"));
//#end
//#end
 */
